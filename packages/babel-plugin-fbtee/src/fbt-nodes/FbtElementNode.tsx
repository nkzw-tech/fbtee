import {
  CallExpression,
  identifier,
  isArrayExpression,
  isCallExpression,
  isExpression,
  isJSXElement,
  isNode,
  isSpreadElement,
  Node,
  ObjectExpression,
  objectExpression,
  objectProperty,
  stringLiteral,
} from '@babel/types';
import invariant from 'invariant';
import type { BindingName, FbtOptionConfig } from '../FbtConstants.tsx';
import {
  FbtBooleanOptions,
  ValidFbtOptions,
  ValidPronounUsagesKeys,
} from '../FbtConstants.tsx';
import FbtNodeChecker from '../FbtNodeChecker.tsx';
import type { CallExpressionArg, ParamSet } from '../FbtUtil.tsx';
import {
  collectOptionsFromFbtConstruct,
  compactNodeProps,
  createRuntimeCallExpression,
  enforceBoolean,
  enforceNodeCallExpressionArg,
  enforceString,
  errorAt,
  expandStringConcat,
  normalizeSpaces,
  setUniqueToken,
  varDump,
} from '../FbtUtil.tsx';
import type { TokenAliases } from '../index.tsx';
import { GENDER_ANY } from '../translate/IntlVariations.tsx';
import type {
  AnyStringVariationArg,
  StringVariationArgsMap,
} from './FbtArguments.tsx';
import { GenderStringVariationArg } from './FbtArguments.tsx';
import FbtEnumNode from './FbtEnumNode.tsx';
import FbtImplicitParamNode from './FbtImplicitParamNode.tsx';
import type FbtImplicitParamNodeType from './FbtImplicitParamNode.tsx';
import FbtNameNode from './FbtNameNode.tsx';
import type { AnyFbtNode, FbtChildNode } from './FbtNode.tsx';
import FbtNode from './FbtNode.tsx';
import { FbtNodeType } from './FbtNodeType.tsx';
import {
  buildFbtNodeMapForSameParam,
  getChildNodeText,
  getChildNodeTextForDescription,
  getTextFromFbtNodeTree,
  getTokenAliasesFromFbtNodeTree,
  runOnNestedChildren,
} from './FbtNodeUtil.tsx';
import FbtParamNode from './FbtParamNode.tsx';
import FbtPluralNode from './FbtPluralNode.tsx';
import FbtPronounNode from './FbtPronounNode.tsx';
import FbtSameParamNode from './FbtSameParamNode.tsx';
import FbtTextNode from './FbtTextNode.tsx';

type ExtraOptionValues = {
  [optionName: string]: string;
};

export type Options = FbtElementNodeNativeOptions & {
  extraOptions: Readonly<ExtraOptionValues>;
};

export type FbtElementNodeNativeOptions = {
  // Author of the strings generated by this fbt callsite
  author: string | null | undefined;
  // If `true`, the fbt text must match an entry from `FbtCommon`,
  // and the string description will be ignored
  common: boolean;
  // If `true`, do not extract strings from this fbt callsite.
  // We'll still transform this callsite to a regular fbt._() using untranslated texts though.
  // When nullish, we'll give priority to the file-level `doNotExtract` annotation
  // to determine whether to extract the phrase.
  doNotExtract: boolean | null | undefined;
  // We normally consolidates whitespace down to one space (`' '`).
  // Turn this off by setting this to `true`
  preserveWhitespace: boolean;
  // fbt project name
  project: string;
  // If defined, the translated string may depend on the gender of the sentence's subject.
  subject: CallExpressionArg | null | undefined;
};

export interface IFbtElementNode {
  _tokenSet: ParamSet;
  /**
   * Returns description of this fbt string for the given map of string variation arguments
   */
  getDescription(argsMap: StringVariationArgsMap): string;
  /**
   * Register a token name
   * @throws if the token name was already registered
   */
  registerToken(name: string, source: AnyFbtNode): void;
}

const childNodeClasses = new Map(
  [
    FbtEnumNode,
    FbtNameNode,
    FbtParamNode,
    FbtPluralNode,
    FbtPronounNode,
    FbtSameParamNode,
  ].map(
    (Constructor) => [Constructor.type as FbtNodeType, Constructor] as const,
  ),
);

/**
 * Represents the main fbt() or <fbt> construct.
 * Every nested fbt construct will be reachable from the `children` property.
 *
 * E.g. When we have an fbt callsite like this:
 *
 *     fbt(
 *       [
 *         'Hello',
 *         <strong>
 *           World!
 *         </strong>
 *       ],
 *       'description',
 *     )
 *
 * We'll represent it like this:
 *
 * FbtElementNode                    // fbt()
 *   |
 *   *- FbtTextNode                  // 'Hello'
 *   *- FbtImplicitParamNode         // <strong/>
 *        |
 *        *- FbtTextNode             // 'World!'
 *
 */
export default class FbtElementNode
  extends FbtNode<AnyStringVariationArg, CallExpression, FbtChildNode, Options>
  implements IFbtElementNode
{
  readonly type = 'element';

  _tokenSet: ParamSet = {};

  override getOptions(validExtraOptions?: Readonly<FbtOptionConfig>): Options {
    const { node } = this;
    const allValidOptions = {
      ...validExtraOptions,
      ...ValidFbtOptions,
    } as const;
    const rawOptions = collectOptionsFromFbtConstruct(
      this.moduleName,
      node,
      allValidOptions,
      FbtBooleanOptions,
    );

    // Build extra options
    const extraOptions: ExtraOptionValues = {};
    for (const optionName of Object.keys(rawOptions)) {
      if (validExtraOptions?.[optionName] == null) {
        continue;
      }
      const extraOptionValue = rawOptions[optionName];
      invariant(
        typeof extraOptionValue === 'string',
        'Expected extra option values to be strings but got `%s` (%s)',
        varDump(extraOptionValue),
        typeof extraOptionValue,
      );
      extraOptions[optionName] = extraOptionValue;
    }

    try {
      return {
        author: enforceString.orNull(rawOptions.author),
        common: enforceBoolean.orNull(rawOptions.common) || false,
        doNotExtract: enforceBoolean.orNull(rawOptions.doNotExtract),
        extraOptions,
        preserveWhitespace:
          enforceBoolean.orNull(rawOptions.preserveWhitespace) || false,
        project: enforceString(rawOptions.project || ''),
        subject:
          typeof rawOptions.subject !== 'string' &&
          typeof rawOptions.subject !== 'boolean' &&
          isExpression(rawOptions.subject)
            ? enforceNodeCallExpressionArg.orNull(rawOptions.subject)
            : null,
      };
    } catch (error) {
      throw errorAt(node, error);
    }
  }

  getExtraOptionsNode(): ObjectExpression | null {
    const { extraOptions } = this.options;
    const extraOptionsObjectProperties = Object.keys(extraOptions).map(
      (optionName) =>
        objectProperty(
          identifier(optionName),
          stringLiteral(extraOptions[optionName]),
        ),
    );
    return extraOptionsObjectProperties.length
      ? objectExpression(extraOptionsObjectProperties)
      : null;
  }

  static getArgsForStringVariationCalcForFbtElement(
    instance: FbtElementNode | FbtImplicitParamNodeType,
    subject?: Node | null,
  ): ReadonlyArray<AnyStringVariationArg> {
    return [
      ...(isNode(subject)
        ? [new GenderStringVariationArg(instance, subject, [GENDER_ANY])]
        : []),
      ...instance.children.flatMap((c) => c.getArgsForStringVariationCalc()),
    ];
  }

  override getArgsForStringVariationCalc(): ReadonlyArray<AnyStringVariationArg> {
    return FbtElementNode.getArgsForStringVariationCalcForFbtElement(
      this,
      this.options.subject,
    );
  }

  /**
   * Run some sanity checks before producing text
   * @throws if some fbt nodes in the tree have duplicate token names
   */
  static beforeGetTextSanityCheck(
    instance: FbtElementNode | FbtImplicitParamNodeType,
    argsMap: StringVariationArgsMap,
  ) {
    instance.children.forEach((child) => {
      const tokenName = child.getTokenName(argsMap);
      // FbtSameParamNode token names are allowed to be redundant by design
      if (tokenName != null && !(child instanceof FbtSameParamNode)) {
        instance.registerToken(tokenName, child);
      }
    });
  }

  /**
   * Run some sanity checks before producing text
   * @throws if some fbt nodes in the tree have duplicate token names
   */
  _beforeGetTextSanityCheck(argsMap: StringVariationArgsMap) {
    FbtElementNode.beforeGetTextSanityCheck(this, argsMap);
  }

  override getText(argsMap: StringVariationArgsMap): string {
    try {
      this._beforeGetTextSanityCheck(argsMap);
      return getTextFromFbtNodeTree(
        this,
        argsMap,
        this.options.subject,
        this.options.preserveWhitespace,
        getChildNodeText,
      );
    } catch (error) {
      throw errorAt(this.node, error);
    }
  }

  getTextForDescription(
    argsMap: StringVariationArgsMap,
    targetFbtNode: FbtImplicitParamNodeType,
  ): string {
    return getTextFromFbtNodeTree(
      this,
      argsMap,
      this.options.subject,
      this.options.preserveWhitespace,
      getChildNodeTextForDescription.bind(null, targetFbtNode),
    );
  }

  /**
   * @see IFbtElementNode#getDescription
   */
  getDescription(_args: StringVariationArgsMap): string {
    const [_, descriptionNode] = this.getCallNodeArguments() || [];
    invariant(
      descriptionNode != null,
      'fbt description argument cannot be found',
    );

    return normalizeSpaces(
      expandStringConcat(this.moduleName, descriptionNode).value,
      { preserveWhitespace: !!this.options.preserveWhitespace },
    ).trim();
  }

  override getTokenAliases(
    argsMap: StringVariationArgsMap,
  ): TokenAliases | null {
    return getTokenAliasesFromFbtNodeTree(this, argsMap);
  }

  /**
   * Create a new class instance given a node root node.
   * If that node is incompatible, we'll just return `null`.
   */
  static fromNode(
    moduleName: BindingName,
    node: Node,
    validExtraOptions: Readonly<FbtOptionConfig>,
  ): FbtElementNode | null {
    if (!isCallExpression(node)) {
      return null;
    }
    const fbtElement = new FbtElementNode({
      moduleName,
      node,
      validExtraOptions,
    });
    const {
      arguments: [fbtContentsNode],
    } = node;

    if (!isArrayExpression(fbtContentsNode)) {
      throw errorAt(
        node,
        `${moduleName}: expected callsite's first argument to be an array`,
      );
    }

    for (const elementChild of fbtContentsNode.elements || []) {
      if (elementChild == null) {
        throw errorAt(node, `${moduleName}: elementChild must not be nullish`);
      }
      if (isSpreadElement(elementChild)) {
        throw errorAt(elementChild, `Array spread syntax is not supported`);
      }
      fbtElement.appendChild(this.createChildNode(moduleName, elementChild));
    }
    return fbtElement;
  }

  /**
   * Create a child fbt node for a given node.
   */
  static createChildNode(moduleName: BindingName, node: Node): FbtChildNode {
    const nodeType = FbtNodeChecker.forModule(moduleName).getFbtNodeType(node);
    const Constructor = nodeType ? childNodeClasses.get(nodeType) : null;
    let childNode: FbtChildNode | null =
      Constructor?.fromNode(moduleName, node) ||
      FbtTextNode.fromNode(moduleName, node);

    // Try to convert to FbtImplicitParamNode as a last resort
    if (childNode == null && isJSXElement(node)) {
      // Later on, we should only allow non-fbt JSX elements here for auto-wrapping.
      // fbt:param, fbt:pronoun, etc... should appear as children of it.
      childNode = FbtImplicitParamNode.fromNode(moduleName, node);
    }

    if (childNode != null) {
      return childNode;
    }

    throw errorAt(node, `${moduleName}: unsupported node: ${node.type}`);
  }

  getImplicitParamNodes(): ReadonlyArray<FbtImplicitParamNodeType> {
    const ret: Array<FbtImplicitParamNode> = [];
    runOnNestedChildren(this, (child) => {
      if (child instanceof FbtImplicitParamNode) {
        ret.push(child);
      }
    });
    return ret;
  }

  override getFbtRuntimeArg(): CallExpression | null {
    const { subject } = this.options;
    return subject == null
      ? null
      : createRuntimeCallExpression(
          this,
          [subject],
          ValidPronounUsagesKeys.subject,
        );
  }

  override getArgsThatShouldNotContainFunctionCallOrClassInstantiation(): Readonly<{
    [argName: string]: CallExpressionArg;
  }> {
    const { subject } = this.options;
    return subject != null ? { subject } : {};
  }

  /**
   * @see IFbtElementNode#registerToken
   */
  registerToken(name: string, source: AnyFbtNode) {
    setUniqueToken(source.node, this.moduleName, name, this._tokenSet);
  }

  static __compactTokenSet(
    obj: Record<string, unknown> & { _tokenSet?: Record<string, unknown> },
  ): unknown {
    invariant(
      obj &&
        typeof obj === 'object' &&
        typeof obj._tokenSet === 'object' &&
        obj._tokenSet,
      'Expected _tokenSet property to be defined',
    );
    obj._tokenSet = compactNodeProps(obj._tokenSet, false);
    return obj;
  }

  override toJSON(): unknown {
    const ret = super.toJSON();
    return FbtElementNode.__compactTokenSet(ret as Record<string, unknown>);
  }

  assertNoOverallTokenNameCollision(
    argsMapList: ReadonlyArray<StringVariationArgsMap>,
  ) {
    argsMapList.forEach((argsMap) => {
      buildFbtNodeMapForSameParam(this, argsMap);
    });
  }
}
